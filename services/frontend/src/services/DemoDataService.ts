import {Account, AccountType, RecurringTransaction, Transaction, TransactionType} from "models/";
import {Id} from "utils/types";
import DateService from "./DateService";
import MathUtils from "./MathUtils";

// 500 - 1500 transactions should get us several years worth.
// Note: This is also a good way to stress-test the app. I found that everything but the charts
// more-or-less works with 10s of thousands of transactions.
const MIN_TRANSACTIONS = 500;
const MAX_TRANSACTIONS = 1500;

const MIN_RECURRING_TRANSACTIONS = 2;
const MAX_RECURRING_TRANSACTIONS = 5;

const ACCOUNT_NAMES = {
    // Look, for some reason, the model imports are all undefined when running in tests.
    // But, like, only at top-level? I don't understand, but we can't access `Account.ASSET` (or anything)
    // other type) because `Account` is undefined. So... hard code it, cause I don't care.
    asset: [
        "Chequing Account",
        "Cash",
        "Savings Account",
        "Retirement Savings",
        "TFSA",
        "Gambling Money",
        "Piggy Bank",
        "Stonks"
    ],
    liability: [
        "Credit Card",
        "Mortgage",
        "Loan to Friend",
        "Line of Credit",
        "Student Loans",
        "Backup Credit Card",
        "That Other Credit Card"
    ],
    income: ["Salary", "Gifts", "Interest", "Other Income", "Side Project", "Under the Table"],
    expense: [
        "Rent",
        "Netflix",
        "Groceries",
        "Takeout",
        "Electronics",
        "Video Games",
        "Phone Bill",
        "Water Bill",
        "Gas Bill",
        "Ramen",
        "Gambling",
        "Sports",
        "uFincs Subscription",
        "Things I Don't Need"
    ]
} as Record<AccountType, Array<string>>;

const INCOME_VERBS = [
    "Received",
    "Got paid",
    "Made",
    "Got",
    "Was given",
    "Found",
    "Sold my right kidney for"
];

const INCOME_NAMES = [
    "a large sum of money",
    "some money",
    "dolla billz",
    "salary",
    "some cash",
    "the check",
    "the payment"
];

const EXPENSE_VERBS = [
    "Acquired",
    "Bought",
    "Paid for",
    "Sold my soul for",
    "Sold my left kidney for",
    "Bartered for",
    "Procured"
];

// Nouns were generated by https://www.randomlists.com/things?show_images=false&dup=false&qty=100.
const EXPENSE_NAMES = [
    "a rubber duck",
    "a blouse",
    "some keys",
    "a shovel",
    "a chalk",
    "a doll",
    "a soda can",
    "a piano",
    "a rubber band",
    "a sketch pad",
    "a toilet",
    "a magnet",
    "a tissue box",
    "a pillow",
    "a candy wrapper",
    "a helmet",
    "a spring",
    "some deodorant",
    "a needle",
    "some air freshener",
    "a cell phone",
    "a bag",
    "a bottle cap",
    "a cork",
    "some stockings",
    "a zipper",
    "a purse",
    "a fork",
    "a cup",
    "a rusty nail",
    "some brocoli",
    "some packing peanuts",
    "a key chain",
    "a camera",
    "a paint brush",
    "a car",
    "some thread",
    "some speakers",
    "a vase",
    "a television",
    "a hair tie",
    "a bed",
    "a box",
    "a sailboat",
    "a sofa",
    "a CD",
    "some flowers",
    "some bread",
    "a newspaper",
    "a mop",
    "a shawl",
    "a glow stick",
    "some shampoo",
    "a flag",
    "a chair",
    "some fake flowers",
    "a bowl",
    "a sandal",
    "a bracelet",
    "a rug",
    "a toe ring",
    "a watch",
    "a sidewalk",
    "a water bottle",
    "some tweezers",
    "a paper",
    "an outlet",
    "a table",
    "a plastic fork",
    "a thermometer",
    "a pencil",
    "some lotion",
    "some sand paper",
    "a radio",
    "some video games",
    "a clock",
    "a soy sauce packet",
    "some grid paper",
    "a balloon",
    "a monitor",
    "some toothpaste",
    "a washing machine",
    "some conditioner",
    "some socks",
    "a controller",
    "some lip gloss",
    "a lamp shade",
    "a credit card",
    "some pants",
    "a couch",
    "a wallet",
    "some soap",
    "some milk",
    "a drill press",
    "a clamp",
    "a bucket",
    "some sun glasses",
    "some white out",
    "a thermostat",
    "an eraser"
];

const TRANSFER_VERBS = [
    "Transferred",
    "Relocated",
    "Removed",
    "Altered",
    "Shifted around",
    "Paid down"
];

// Note: All random values (i.e. everything for getRandomInt) were more-or-less just randomly picked,
// with some experimentation to try and get the final result such that the net worth is positive.
// Why would we want the net worth to be positive? Cause we don't want to depress our potential customers...

export default class DemoDataService {
    static generateDemoData() {
        const accounts = DemoDataService.generateAccounts();
        const recurringTransactions = DemoDataService.generateRecurringTransactions(accounts);
        const transactions = DemoDataService.generateTransactions(accounts);

        const accountsById = (Object.keys(accounts) as Array<AccountType>).reduce((acc, type) => {
            for (const account of accounts[type]) {
                acc[account.id] = account;
            }

            return acc;
        }, {} as Record<Id, Account>);

        return {accounts: accountsById, recurringTransactions, transactions};
    }

    static generateAccounts(): Record<AccountType, Array<Account>> {
        return (Object.keys(ACCOUNT_NAMES) as Array<AccountType>).reduce((acc, type) => {
            const names = ACCOUNT_NAMES[type];
            const namesSubset = pickRandomElements(
                names,
                names.length - MathUtils.getRandomInt(1, 4)
            );

            acc[type] = namesSubset.map(
                (name) =>
                    new Account({
                        name,
                        type,
                        openingBalance:
                            type === Account.ASSET
                                ? MathUtils.getRandomInt(100000, 1000000)
                                : type === Account.LIABILITY
                                ? MathUtils.getRandomInt(0, 100000)
                                : 0
                    })
            );

            return acc;
        }, {} as Record<AccountType, Array<Account>>);
    }

    static generateTransactions(
        accounts: Record<AccountType, Array<Account>>
    ): Record<Id, Transaction> {
        const numberOfTransactions = MathUtils.getRandomInt(MIN_TRANSACTIONS, MAX_TRANSACTIONS);
        const transactions: Record<Id, Transaction> = {};

        const today = DateService.getTodayDate();

        for (let i = 0; i < numberOfTransactions; i++) {
            const type = getRandomTransactionType();
            const {creditAccountId, debitAccountId} = pickRandomAccounts(type, accounts);

            const date = DateService.subtractDays(today, i * MathUtils.getRandomInt(1, 5));

            const transaction = new Transaction({
                creditAccountId,
                debitAccountId,
                amount: pickRandomAmount(),
                date,
                description: pickRandomDescription(type),
                type
            });

            transactions[transaction.id] = transaction;
        }

        return transactions;
    }

    static generateRecurringTransactions(
        accounts: Record<AccountType, Array<Account>>
    ): Record<Id, RecurringTransaction> {
        const numberOfTransactions = MathUtils.getRandomInt(
            MIN_RECURRING_TRANSACTIONS,
            MAX_RECURRING_TRANSACTIONS
        );

        const recurringTransactions: Record<Id, RecurringTransaction> = {};
        const recurringSchedules = DemoDataService._generateRecurringSchedules();

        const today = DateService.getTodayDate();

        for (let i = 0; i < numberOfTransactions; i++) {
            const type = getRandomTransactionType();
            const {creditAccountId, debitAccountId} = pickRandomAccounts(type, accounts);

            const recurringTransaction = new RecurringTransaction({
                creditAccountId,
                debitAccountId,
                amount: pickRandomAmount(),
                startDate: today,
                description: pickRandomDescription(type),
                type,
                ...pickRandomElement(recurringSchedules)
            });

            recurringTransactions[recurringTransaction.id] = recurringTransaction;
        }

        return recurringTransactions;
    }

    static _generateRecurringSchedules() {
        const recurringSchedules: Array<
            Partial<
                Pick<
                    RecurringTransaction,
                    "interval" | "freq" | "on" | "endDate" | "count" | "neverEnds"
                >
            >
        > = [
            {
                interval: MathUtils.getRandomInt(5, 30),
                freq: RecurringTransaction.FREQUENCIES.daily,
                neverEnds: true
            },
            {
                interval: MathUtils.getRandomInt(1, 4),
                freq: RecurringTransaction.FREQUENCIES.weekly,
                on: MathUtils.getRandomInt(1, 6),
                neverEnds: true
            },
            {
                interval: 1,
                freq: RecurringTransaction.FREQUENCIES.monthly,
                on: MathUtils.getRandomInt(1, 25),
                count: MathUtils.getRandomInt(12, 48)
            },
            {
                interval: 1,
                freq: RecurringTransaction.FREQUENCIES.yearly,
                count: MathUtils.getRandomInt(5, 10)
            }
        ];

        return recurringSchedules;
    }
}

/** Found from https://stackoverflow.com/a/19270021. */
const pickRandomElements = <T>(arr: Array<T>, n: number): Array<T> => {
    let len = arr.length;

    const result = new Array(n);
    const taken = new Array(len);

    if (n > len) throw new RangeError("getRandom: more elements taken than available");

    while (n--) {
        const x = Math.floor(Math.random() * len);
        result[n] = arr[x in taken ? taken[x] : x];
        taken[x] = --len in taken ? taken[len] : len;
    }

    return result;
};

const pickRandomElement = <T>(arr: Array<T>): T => {
    return arr[MathUtils.getRandomInt(0, arr.length)];
};

const getRandomTransactionType = (): TransactionType => {
    const number = Math.random();

    if (number < 0.25) {
        return Transaction.EXPENSE;
    } else if (number >= 0.25 && number < 0.45) {
        return Transaction.DEBT;
    } else if (number >= 0.45 && number < 0.9) {
        // Want income to show a good portion of the time, so that the final net worth is hopefully positive.
        return Transaction.INCOME;
    } else {
        return Transaction.TRANSFER;
    }
};

const pickRandomAccounts = (
    type: TransactionType,
    accounts: Record<AccountType, Array<Account>>
): {creditAccountId: string; debitAccountId: string} => {
    const assets = accounts[Account.ASSET];
    const liabilities = accounts[Account.LIABILITY];
    const incomes = accounts[Account.INCOME];
    const expenses = accounts[Account.EXPENSE];

    let creditAccountId: string = "";
    let debitAccountId: string = "";

    switch (type) {
        case Transaction.INCOME:
            creditAccountId = pickRandomElement(incomes).id;
            debitAccountId = pickRandomElement(assets).id;
            break;
        case Transaction.EXPENSE:
            creditAccountId = pickRandomElement(assets).id;
            debitAccountId = pickRandomElement(expenses).id;
            break;
        case Transaction.DEBT:
            creditAccountId = pickRandomElement(liabilities).id;
            debitAccountId = pickRandomElement(expenses).id;
            break;
        case Transaction.TRANSFER:
            creditAccountId = pickRandomElement(assets).id;

            if (Math.random() < 0.5) {
                debitAccountId = pickRandomElement(assets).id;
            } else {
                debitAccountId = pickRandomElement(liabilities).id;
            }

            break;
    }

    return {creditAccountId, debitAccountId};
};

const pickRandomDescription = (type: TransactionType): string => {
    let description = "";

    switch (type) {
        case Transaction.INCOME:
            description = `${pickRandomElement(INCOME_VERBS)} ${pickRandomElement(INCOME_NAMES)}`;
            break;
        case Transaction.EXPENSE:
        // Falls through.
        case Transaction.DEBT:
            description = `${pickRandomElement(EXPENSE_VERBS)} ${pickRandomElement(EXPENSE_NAMES)}`;
            break;
        case Transaction.TRANSFER:
            description = `${pickRandomElement(TRANSFER_VERBS)} ${pickRandomElement(INCOME_NAMES)}`;
            break;
    }

    return description;
};

const pickRandomAmount = (): number => {
    const magnitude = Math.random();

    if (magnitude < 0.5) {
        return MathUtils.getRandomInt(0, 10000);
    } else if (magnitude >= 0.5 && magnitude < 0.8) {
        return MathUtils.getRandomInt(10000, 100000);
    } else if (magnitude >= 0.8 && magnitude < 0.95) {
        return MathUtils.getRandomInt(100000, 1000000);
    } else {
        return MathUtils.getRandomInt(1000000, 10000000);
    }
};
